# 💡 LicheeRV Nano 学习笔记（三）：按键点灯 —— Input 子系统

## 一、 原理说明：什么是 Input 子系统？

在 Linux 中，键盘、鼠标、触摸屏、按键都被统一抽象为“输入设备”。

1. **内核端**：内核通过 `gpio-keys` 驱动监听引脚电平。当电平变化（按键按下或松开）时，内核会生成一个名为 `input_event` 的结构体数据。
2. **应用端**：我们的程序通过读取 `/dev/input/event0` 文件，就能像读短信一样收到这个结构体。

**好处**：你的程序不需要死循环轮询，`read()` 函数会自动阻塞（休眠），直到你按下按键时才会被内核“叫醒”。这极大地节省了 CPU 资源。

---

## 二、 编写 C 语言程序

在虚拟机 `led_driver` 目录下创建 `key_led_input.c`：

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/input.h> // 必须包含这个头文件，它定义了 input_event 结构体

#define LED_BRIGHTNESS "/sys/class/leds/led-user/brightness"
#define KEY_DEVICE     "/dev/input/event0" // 根据你 lsblk 查到的结果

int main() {
    int fd_key, fd_led;
    struct input_event ev; // 定义输入事件结构体

    // 1. 初始化 LED 模式
    system("echo none > /sys/class/leds/led-user/trigger");

    // 2. 打开设备文件
    fd_key = open(KEY_DEVICE, O_RDONLY);
    fd_led = open(LED_BRIGHTNESS, O_WRONLY);

    if (fd_key < 0 || fd_led < 0) {
        perror("无法打开设备文件");
        return -1;
    }

    printf("Input 子系统程序已启动！正在监听 event0...\n");
    printf("提示：按下板子按键点亮蓝灯，松开熄灭。\n");

    while (1) {
        // 3. 阻塞式读取：只有按键发生动作，这里才会返回
        // 没按按键时，程序在这里休眠，不占 CPU
        if (read(fd_key, &ev, sizeof(struct input_event)) > 0) {
        
            // 4. 判断事件类型：EV_KEY 代表按键事件
            if (ev.type == EV_KEY) {
                // ev.value: 1 代表按下, 0 代表松开, 2 代表长按(重复)
                if (ev.value == 1) {
                    write(fd_led, "1", 1);
                    printf("Key Pressed [ON]\n");
                } else if (ev.value == 0) {
                    write(fd_led, "0", 1);
                    printf("Key Released [OFF]\n");
                }
            }
        }
    }

    close(fd_key);
    close(fd_led);
    return 0;
}
```

---

## 三、 交叉编译与部署

在虚拟机中执行：

```bash
# 1. 静态编译
riscv64-linux-gnu-gcc -static key_led_input.c -o key_led_input

# 2. 挂载 SD 卡并拷贝 (假设为 sdb2)
sudo mount /dev/sdb2 ~/temp_sd
sudo cp key_led_input ~/temp_sd/root/
sync
sudo umount ~/temp_sd
```

---

## 四、 板端运行

插回 SD 卡，上电。在串口终端执行：

```bash
cd /root
chmod +x key_led_input
./key_led_input
```

**运行效果**：

* 按下板载按键，蓝灯亮；松开，蓝灯灭。
* 你会发现程序的响应非常灵敏。
* 如果你打开另一个终端输入 `top` 观察，你会发现这个进程的 CPU 占用率几乎是 **0%**。

---

## 五、 深度解析：`input_event` 结构体

当你读取 `/dev/input/event0` 时，内核返回的包长这样：

* **`type`**：事件类型。我们只关心 `EV_KEY`（按键动作）。
* **`code`**：哪个键被按了。在你的 DTS 里定义的是 `KEY_DISPLAYTOGGLE`，对应的数值可以在头文件里查到。因为我们的板子只有一个按键，所以暂时不需要判断 code。
* **`value`**：状态。`1` 按下，`0` 松开。

---

## 六、思考

假设你的 LicheeRV Nano 现在正在同时运行**四个不同类型的程序**。这四个程序都在自己的 `while(1)` 循环里。

### 1. 角色设定（四个正在运行的任务）

1. **任务 A：按键点灯程序**（你写的代码）。调用 `read()` 等待按键。
2. **任务 B：简单网页服务器**。调用 `accept()` 等待网络上的用户访问。
3. **任务 C：日志存储程序**。调用 `write()` 把系统状态存入 SD 卡。
4. **任务 D：圆周率计算程序**。纯 CPU 运算，不等待任何硬件。

---

### 2. 内核管理的三张“名单” (Process States)

内核就像一个极其严格的经理，手上有三张表：

* **运行中的唯一（Running）**：当前正在霸占 CPU 核心的那个任务（单核 CPU 每次只能跑一个）。
* **就绪名单（Ready List）**：万事俱备，只要 CPU 一空闲，立刻就能跑。
* **阻塞名单（Blocked/Wait List）**：都在“睡觉”，等待各自的硬件信号。

---

### 3. 第一幕：大多数时间的“静默”状态

假设此时没人按按键，没人访问网页，磁盘也写完了。


| 名单类型          | 任务成员                                                      | 状态描述                               |
| :---------------- | :------------------------------------------------------------ | :------------------------------------- |
| **Running (CPU)** | **任务 D**                                                    | 正在疯狂计算圆周率，CPU 满载。         |
| **Ready List**    | (空)                                                          | 暂时没有别的想跑的任务。               |
| **Blocked List**  | **任务 A** (等按键)、**任务 B** (等网络)、**任务 C** (等磁盘) | 都在“小黑屋”里睡觉，不消耗任何 CPU。 |

**解析：** 此时任务 A, B, C 虽然代码里都有 `while(1)`，但它们都卡在了系统调用里，内核把它们丢进了“阻塞名单”。CPU 此时 100% 的精力都在任务 D 身上。

---

### 4. 第二幕：突发事件 —— 按键被按下！

就在这时，你按下了板子上的按键。

1. **硬件电击**：GPIO 产生电脉冲，直接打断任务 D。
2. **内核接管**：CPU 强行跳到内核的中断处理函数。
3. **子系统响应**：Input 子系统发现是按键。
4. **唤醒操作**：内核去“阻塞名单”里翻找，发现**任务 A** 在等这个信号。

**此时，名单发生了变化：**


| 名单类型          | 任务成员                                 | 状态描述                                                                              |
| :---------------- | :--------------------------------------- | :------------------------------------------------------------------------------------ |
| **Running (CPU)** | **任务 D**                               | 被短暂打断后，继续回去算圆周率。                                                      |
| **Ready List**    | **任务 A**                               | **变动：** 任务 A 从阻塞名单被踢到了就绪名单。它现在“醒了”，等待 CPU 给它一点时间。 |
| **Blocked List**  | **任务 B** (等网络)、**任务 C** (等磁盘) | 继续睡觉。                                                                            |

---

### 5. 第三幕：时间片轮转 —— 轮到任务 A 了

内核的调度器说：“任务 D 算太久了，给任务 A 跑一会儿。”

1. **保存现场**：把任务 D 的计算进度存起来。
2. **任务 A 登台**：把任务 A 放到 Running 状态。

此时任务 A 的代码终于从 `read()` 函数**返回了**！

```c
// 任务 A 的视角
read(fd, &ev, ...); // <-- 刚才卡在这里，现在终于醒了并拿到了数据
write_led(1);       // 亮灯！(这行代码消耗了 CPU 微秒级的时间)
// 循环回去，再次调用 read()
read(fd, ...);      // <-- 又没有按键了，任务 A 再次主动请求：“我继续睡觉”。
```

**瞬间，名单再次回归静默：**
任务 A 仅仅活跃了几微秒，做完了亮灯动作，就又把自己关进了“阻塞名单”。

---

### 6. 第四幕：多个子系统并发是什么样？

如果此时**按键被按下**的同时，**网络请求也来了**：

1. 内核会把任务 A（按键）和任务 B（网络）都丢进 **Ready List（就绪名单）**。
2. 调度器会让它们排队：
   * 先给任务 A 跑 1 毫秒 -> 任务 A 亮完灯又去睡了。
   * 再给任务 B 跑 1 毫秒 -> 任务 B 把网页发给用户，也去睡了。
3. CPU 再次回到任务 D 手里，继续算圆周率。

---

### 7. 回答你的核心疑虑

**“如果一直在 read，不就是一直在触发系统调用吗？”**

通过上面的流程，你会发现：

* **触发次数**：`read` 系统调用的发起，**必须**等上一次 `read` 成功返回。
* **阻塞的本质**：当硬件没动静时，`read` 是**不返回**的。
* **所谓的并发**：不是每个子系统都在后台跑一个 `while(1)`。真实的场景是：所有的子系统驱动程序都在内核里**静静地躺着**，它们只是在**“订阅”**中断信号。

**子系统代码的真相：**
驱动代码里通常没有 `while(1)`。驱动代码是一堆“回调函数”（像菜单一样）。

* “如果按键响了，请执行我这段代码。”
* “如果网线有数据了，请执行我这段代码。”

**总结：**

* **CPU 工作清单**：由**调度器**管理，只给“醒着”的人分配时间。
* **系统调用**：是任务从“运行”状态进入“阻塞”状态的门票，也是它们被唤醒后返回用户空间的出口。
* **省电/高效的秘密**：就在于内核能够精准地让不干活的程序“彻底停下”，而不仅仅是“空转”。

**你现在能感受到任务 A 那个 `while(1)` 为什么像是一个“陷阱”，只有按键按下去时才会被触发一次了吗？**
