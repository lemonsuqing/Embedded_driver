# 💡 LicheeRV Nano 硬件控制入门：蓝灯实战手册

在嵌入式 Linux 的世界里，点亮一颗灯并不只是“通电”，而是一次穿越**用户空间、内核空间到物理硬件**的旅行。

---

## 第一章：寻找门牌号 —— 为什么是 `/sys/class/leds`？

### 1. 操作：寻找系统中的灯

输入以下命令，看看你的系统里有哪些被“官方认证”的灯：

```bash
ls /sys/class/leds/
# 输出通常包含：led-user  mmc0::  mmc1::
```

### 2. 原理：设备树 (Device Tree) 与 抽象

* **为什么灯在这里？**
  Linux 内核为了统一管理，把所有灯都放在 `/sys/class/leds/` 目录下。
* **谁定义的 `led-user`？**
  在你编译镜像时，SDK 源码里有一个文件叫 **设备树 (DTS)**。它像一份“硬件说明书”，明确告诉内核：“在 CPU 的 GPIO 442 引脚上接了一个蓝色 LED，请给它起个名字叫 `led-user`”。
* **为什么红灯/绿灯不在这里？**
  因为在默认的说明书（DTS）里，工程师只登记了蓝灯。红灯和绿灯目前是“无证散户”，所以它们没有专属文件夹，只能去更底层的 `/sys/class/gpio` 里碰运气。

---

## 第二章：谁在控制灯？ —— 核心文件 `trigger`

这是初学者最容易掉进去的坑：**明明写了开灯，灯却自己乱闪。**

### 1. 原理：触发器 (Trigger) 机制

Linux 内核非常强大，它可以让灯自动关联某些事件（如心跳、磁盘读写）。这种自动关联就叫 **Trigger**。

* **自动驾驶模式**：如果 trigger 是 `[activity]`，内核会自动根据 CPU 忙碌程度闪烁灯。
* **手动驾驶模式**：只有把 trigger 设为 `none`，内核才会断开自动连接，把控制权交还给你。

### 2. 操作：夺回控制权

```bash
# 1. 查看当前模式
cat /sys/class/leds/led-user/trigger
# 你会看到类似：none ... [activity] ...
# 中括号 [] 里的单词就是当前正在霸占控制权的“人”。

# 2. 强行切换为手动模式
echo none > /sys/class/leds/led-user/trigger
```

**为什么要这样做？**
如果不执行这一步，你手动写的开关命令会被内核的自动程序瞬间覆盖。就像你在划船，如果不松开自动船桨，你自己怎么使劲都没用。

---

## 第三章：真正点亮它 —— `brightness` 文件

### 1. 操作：手动开关

```bash
# 点亮
echo 1 > /sys/class/leds/led-user/brightness

# 熄灭
echo 0 > /sys/class/leds/led-user/brightness
```

### 2. 原理：虚拟文件系统 (Sysfs)

当你执行 `echo 1 > brightness` 时，发生的链路是：

1. **Shell**：把字符 "1" 交给系统内核。
2. **内核 LED 驱动**：识别到 "1"，查找设备树，发现 `led-user` 对应 GPA26（GPIO 442）引脚。
3. **寄存器操作**：内核向 CPU 内部的电平控制寄存器写入一个位（Bit）。
4. **物理引脚**：引脚电压发生变化，LED 导通。

**注意：** 为什么有些灯写 `0` 亮，写 `1` 灭？
这叫**低电平触发 (Active Low)**。如果 LED 的正极接着电源，负极接在 CPU 引脚上，那么 CPU 输出低电平（0V）时，电荷才会流动，灯才会亮。

---

## 第四章：总结点灯流程

如果你拿到一块新的 Linux 开发板，控制 LED 的标准逻辑应该是：

1. **扫描**：`ls /sys/class/leds/` 看看有没有现成的接口。
2. **检查**：`cat .../trigger` 看看是不是 `none`。
3. **切断**：`echo none > .../trigger` 确保自己拥有绝对控制权。
4. **执行**：向 `brightness` 写入 `0` 或 `1`。
5. **观察**：如果命令成功但灯不亮，考虑是否是 **Pinmux（引脚复用）** 冲突，即引脚此时被当成了串口或其他功能，需要修改底层配置。
